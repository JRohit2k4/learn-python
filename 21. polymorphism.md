## Polymmorphism: 
- Greek word that means to "Have many forms or faces"
- Poly = Many
- Morph = Form
- It allows objects of different classes to be treated as objects of a common superclass or simply to respond to the same method in different ways.

**TWO WAYS TO ACHIEVE POLYMORPHISM:** 
1. Inheritance = An object could be treated of the same type as a parent class
2. Duck typing = "If it walks like a duck and quacks like a duck, it must be a duck."  
(Object just needs to have the required methods/attributes, regardless of its class hierarchy).


**Polymorphism using Inheritance :**
```python
from abc import ABC, abstractmethod


class Shape(ABC):
    
    @abstractmethod
    def area(self):
      pass

class Circle(Shape):
    def __init__(self, radius):
      self.radius = radius

    def area(self):
      return 3.14 * self.radius ** 2
  

class Square(Shape):
    def __init__(self, side):
      self.side = side

    def area(self):
      return self.side ** 2
  

class Triangle(Shape):
    def __init__(self, base, height):
      self.base = base
      self.height = height

    def area(self):
      return self.base * self.height * 0.5 

#polymorphism in action
shape = [Circle(5), Square(4), Triangle(3,4)]

for shape in shape:
    print(f"{shape.area()} cmÂ²")

```

**Polymorphism using Duck Typing :**

```python

class Animal():
   alive = True

class Dog(Animal):
   def speak(self):
      print("WOOF!")

class Cat(Animal):
   def speak(self):
      print("MEOW!")

class Car:          #Not related to Animal
   def speak(seld):
      print("HONK!")

#Polymorphism in action
animals = [Dog(), Cat()]

for animal in animals:
   animal.speak()

```
ðŸ‘‰ **Notice:** **Car** is not an **Animal**, but *Python* doesnâ€™t mind â€” as long as the object has the **speak()** method, it works.  
Thatâ€™s the essence of **duck typing** in *Python*.
